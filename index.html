<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Ticker continuo</title>
  <style>
    html, body {
      margin:0;
      padding:0;
    }

    /* Reserva espacio y evita solaparse con el menú */
    #ticker-container {
      display: block;
      position: relative;
      z-index: 1000;
      overflow: hidden;
      background: #14282d;
      color: #e0e1dd;
      height: 40px;           /* ajusta si tu menú requiere más separación */
      line-height: 40px;
      font-family:"Open Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size:13px;
    }

    /* Track inline: tres copias en fila */
    #ticker-track {
      display: inline-flex;
      white-space: nowrap;
      will-change: transform;
      transform: translateX(0);
    }

    .ticker-inner {
      display: inline-block;
      white-space: nowrap;
    }

    .ticker-item {
      display:inline-block;
      margin:0 25px;
      font-weight:bold;
    }
    .ticker-up   { color:#00d26a; }
    .ticker-down { color:#ff3b3b; }
    .ticker-flat { color:#ffd400; }

    @media (max-width: 768px) {
      #ticker-container { height: 32px; line-height: 32px; font-size:12px; }
      .ticker-item { margin: 0 18px; }
    }
  </style>
</head>
<body>
  <div id="ticker-container">
    <div id="ticker-track">
      <div id="seg1" class="ticker-inner">Cargando datos...</div>
      <div id="seg2" class="ticker-inner"></div>
      <div id="seg3" class="ticker-inner"></div>
    </div>
  </div>

  <script>
  let pos = 0;            // posición actual del track
  let segWidth = 0;       // ancho de una copia (seg1)
  let speed = 50 / 60;    // píxeles por frame (~50px/s a 60fps)
  let rafId = null;

  async function loadTicker() {
    try {
      const res = await fetch("https://ticker.maurorojasbiz.workers.dev/");
      const data = await res.json();

      const seg1 = document.getElementById("seg1");
      const seg2 = document.getElementById("seg2");
      const seg3 = document.getElementById("seg3");

      seg1.innerHTML = "";
      seg2.innerHTML = "";
      seg3.innerHTML = "";

      function addItem(label, obj, target) {
        const span = document.createElement("span");
        span.className = "ticker-item";
        if (obj && obj.usd != null) {
          const change = Number(obj.change);
          if (change > 0) span.classList.add("ticker-up");
          else if (change < 0) span.classList.add("ticker-down");
          else span.classList.add("ticker-flat");
          span.textContent = label + ": " + obj.usd.toFixed(2) + " (" + change + "%)";
        } else {
          span.classList.add("ticker-flat");
          span.textContent = label + ": —";
        }
        target.appendChild(span);
      }

      // Criptos
      addItem("₿ BTC", data.crypto?.BTC, seg1);
      addItem("Ξ ETH", data.crypto?.ETH, seg1);
      addItem("◎ SOL", data.crypto?.SOL, seg1);
      addItem("BNB",   data.crypto?.BNB, seg1);
      addItem("RARI",  data.crypto?.RARI, seg1);
      addItem("ZORA",  data.crypto?.ZORA, seg1);

      // Índices
      function addIndex(label, value, target) {
        const span = document.createElement("span");
        span.className = "ticker-item ticker-flat";
        span.textContent = label + ": " + (value ?? "—");
        target.appendChild(span);
      }
      addIndex("S&P500",  data.indices?.sp500,   seg1);
      addIndex("Nasdaq",  data.indices?.nasdaq,  seg1);
      addIndex("DowJones",data.indices?.dowjones,seg1);

      // Clonar contenido en seg2 y seg3
      seg2.innerHTML = seg1.innerHTML;
      seg3.innerHTML = seg1.innerHTML;

      // Medir ancho real de una copia
      await new Promise(requestAnimationFrame);
      segWidth = seg1.scrollWidth;

      // Reiniciar loop con posición alineada al ancho de una copia
      startLoop(true);

    } catch (err) {
      document.getElementById("seg1").textContent = "Error cargando datos";
      console.error("Ticker error:", err);
    }
  }

  function startLoop(resetPos = false) {
    cancelLoop();

    if (resetPos) {
      // Alinea la posición al múltiplo del ancho para evitar micro saltos al reanudar
      pos = pos % segWidth;
    }

    const track = document.getElementById("ticker-track");

    function step() {
      pos -= speed; // avanza hacia la izquierda

      // Wrap continuo: cuando se desplazó una copia completa, restamos su ancho
      // Esto evita cualquier reinicio visible o solapamiento.
      if (pos <= -segWidth) {
        pos += segWidth;
      }

      track.style.transform = `translateX(${pos}px)`;
      rafId = requestAnimationFrame(step);
    }

    rafId = requestAnimationFrame(step);
  }

  function cancelLoop() {
    if (rafId != null) {
      cancelAnimationFrame(rafId);
      rafId = null;
    }
  }

  // Recalcular en resize para mantener continuidad sin saltos
  window.addEventListener("resize", async () => {
    const seg1 = document.getElementById("seg1");
    await new Promise(requestAnimationFrame);
    const newWidth = seg1.scrollWidth;

    if (newWidth && newWidth !== segWidth) {
      // Ajusta posición al nuevo ancho manteniendo la fase del scroll
      const phase = (-pos) % segWidth;            // cuánto de la copia ya se desplazó
      segWidth = newWidth;
      pos = -(phase % segWidth);                  // reubica sin brinco
    }
  });

  // Carga inicial y refresco cada 5 minutos
  loadTicker();
  setInterval(async () => {
    await loadTicker();
  }, 300000);
  </script>
</body>
</html>
